if not config:

    configfile: "config/config.yaml"


TREE_METHOD = "iqtree"


build_names = [
    "lineage-b.1",
    "clade-iib",
    "all-clades",
    "clade-i",
]
# build_names = ["lineage-b.1", "clade-iib", "all-clades"]
# build_names = ["all-clades"]

PREALIGN_REFERENCE = "resources/lineage-b.1/reference.fasta"
PREMASK_BED = "resources/lineage-b.1/mask.bed"

dataset_files = [
    "pathogen.json",
    "sequences.fasta",
    "genome_annotation.gff3",
    "README.md",
    "CHANGELOG.md",
]


# Helper functions to allow build-specific annotations
def annotation_path(wildcards):
    if "annotation" in config[wildcards.build_name]:
        return config[wildcards.build_name]["annotation"]
    return "resources/genome_annotation.gff3"


def gene_path(wildcards):
    if "genes" in config[wildcards.build_name]:
        return config[wildcards.build_name]["genes"]
    return "resources/genes.txt"


def genes(wildcards):
    gene_file = gene_path(wildcards)
    genes = [line.strip() for line in open(gene_file)]
    return genes


rule all:
    input:
        datasets=expand(
            "datasets/{dataset}/{file}", dataset=build_names, file=dataset_files
        ),
        tests=expand("test_output/{dataset}", dataset=build_names),
        duplicates=expand("results/{dataset}/duplicates.txt", dataset=build_names),


rule deploy_to_nextstrain_staging:
    input:
        rules.all.input,
    shell:
        """
        nextstrain deploy s3://nextstrain-staging {input}
        """


rule download:
    "Downloading ingested sequences and metadata from data.nextstrain.org"
    output:
        sequences="data/sequences.fasta.zst",
        metadata="data/metadata.tsv.zst",
    params:
        sequences_url="https://lapis.pathoplexus.org/mpox/sample/unalignedNucleotideSequences?downloadAsFile=true&downloadFileBasename=mpox_nuc_2025-03-19T1422&versionStatus=LATEST_VERSION&isRevocation=false&dataFormat=fasta&compression=zstd",
        metadata_url="https://lapis.pathoplexus.org/mpox/sample/details?downloadAsFile=true&downloadFileBasename=mpox_metadata_2025-03-19T1422&versionStatus=LATEST_VERSION&isRevocation=false&dataFormat=tsv&compression=zstd",
    shell:
        """
        curl -fsSL --compressed {params.sequences_url:q} --output {output.sequences}
        curl -fsSL --compressed {params.metadata_url:q} --output {output.metadata}
        """


rule decompress:
    "Decompressing sequences and metadata"
    input:
        sequences="data/sequences.fasta.zst",
        metadata="data/metadata.tsv.zst",
    output:
        sequences="data/sequences.fasta",
        metadata="data/metadata.tsv",
    shell:
        """
        zstd --decompress --keep {input.metadata}
        zstdcat {input.sequences} \
        | seqkit replace \
            -p "^([^.]+).*" -r '$1' \
        > {output.sequences}
        """


rule remove_known_duplicates:
    input:
        known_duplicates="resources/known_duplicates.txt",
        sequences="data/sequences.fasta",
    output:
        sequences_without_known_duplicates="results/sequences_without_known_duplicates.fasta",
    shell:
        """
        seqkit grep -w0 -v -f {input.known_duplicates} {input.sequences} > {output.sequences_without_known_duplicates}
        """


rule index:
    "Indexing sequences"
    input:
        sequences="results/sequences_without_known_duplicates.fasta",
    output:
        index="results/index.tsv",
    shell:
        """
        augur index \
            --sequences {input.sequences} \
            --output {output.index}
        """


rule prealign:
    input:
        sequences="results/sequences_without_known_duplicates.fasta",
    output:
        alignment="results/prealigned.fasta",
        stats="results/prealign_stats.tsv",
    shell:
        """
        nextclade3 run \
            {input.sequences} \
            -d nextstrain/mpox/all-clades \
            --output-fasta /dev/stdout \
            --include-reference \
            -t {output.stats} \
        | sed 's/ |(reverse complement)$//' > {output.alignment}
        """


rule filter_nextclade_results:
    input:
        stats="results/prealign_stats.tsv",
    output:
        stats="results/prealign_stats_filtered.tsv",
    shell:
        """
        tsv-filter \
            --header \
            --lt 'privateNucMutations.totalPrivateSubstitutions':25 \
            {input.stats} \
        > {output.stats}
        """


rule join_metadata:
    input:
        metadata="data/metadata.tsv",
        stats=rules.filter_nextclade_results.output.stats,
    output:
        metadata="results/metadata.tsv",
    shell:
        """
        tsv-join \
            --header \
            --filter-file {input.stats} \
            --data-fields accession \
            --key-fields seqName \
            --append-fields 1-20,'privateNucMutations.totalPrivateSubstitutions' \
            {input.metadata} \
        | sed '1s/sampleCollectionDate/date/' \
        > {output.metadata}
        """


rule exclude_bad:
    # Removing strains that do not satisfy certain requirements.
    input:
        sequences="results/sequences_without_known_duplicates.fasta",
        metadata="results/metadata.tsv",
        index="results/index.tsv",
    output:
        sequences="results/decent_sequences.fasta",
        metadata="results/decent_metadata_raw.tsv",
        log="results/decent_filter.log",
    shell:
        """
        augur filter \
            --sequences {input.sequences} \
            --sequence-index {input.index} \
            --metadata-id-columns accession \
            --metadata {input.metadata} \
            --output-sequences {output.sequences} \
            --output-metadata {output.metadata} \
            --min-length 150000 \
            --output-log {output.log}
        """


rule premask:
    input:
        sequences="results/prealigned.fasta",
        mask=PREMASK_BED,
    output:
        "results/premasked.fasta",
    shell:
        """
        augur mask \
            --sequences {input.sequences} \
            --mask {input.mask} \
            --output {output}
        """


rule deduplicate:
    """
    Remove identical sequences (even if they have differing Ns)
    Keep those sequences with fewer Ns
    Focus for Nextclade is on diversity, not on representativeness
    """
    input:
        sequences="results/premasked.fasta",
    output:
        "results/duplicates.txt",
    shell:
        """
        python3 scripts/deduplicate.py {input.sequences} {output}
        """


rule reformat_ambiguous:
    input:
        metadata="results/decent_metadata_raw.tsv",
    output:
        metadata="results/decent_metadata.tsv",
    run:
        import pandas as pd

        df = pd.read_csv(input.metadata, sep="\t", keep_default_na=False)


        def replace_ambiguous_date(date):
            if date == "":
                return "XXXX-XX-XX"
            parts = date.split("-")
            year = parts[0]
            rest = [p.zfill(2) for p in parts[1:]]
            while len(rest) < 2:
                rest.append("XX")
            return "-".join([year] + rest)


        df["date"] = df["date"].apply(replace_ambiguous_date)

        df.to_csv(output.metadata, sep="\t", index=False)


rule subsample_b1:
    input:
        sequences="results/decent_sequences.fasta",
        metadata="results/decent_metadata.tsv",
        exclude="resources/exclude_accessions.txt",
        specific_exclude="resources/{build_name}/exclude_accessions.txt",
        deduplicate_exclude="results/duplicates.txt",
        specific_include="resources/{build_name}/include_accessions.txt",
        include=lambda w: config[w.build_name]["general_include"],
        index="results/index.tsv",
    output:
        sequences="results/{build_name}/filtered_raw.fasta",
        metadata="results/{build_name}/filtered_raw_metadata.tsv",
        log="results/{build_name}/filtered_raw.log",
        strains="results/{build_name}/strains_b1.txt",
    params:
        min_date=lambda w: config[w.build_name]["min_date"],
        min_length=config["min_length"],
        exclude_where=lambda w: config[w.build_name]["exclude_where"]["b1"],
        subsampling=lambda w: config[w.build_name]["subsampling"]["b1"],
    shell:
        """
        augur filter \
            --sequences {input.sequences} \
            --metadata {input.metadata} \
            --sequence-index {input.index} \
            --metadata-id-columns accession \
            --exclude {input.exclude} {input.specific_exclude} {input.deduplicate_exclude} \
            {params.exclude_where} \
            {params.min_date} \
            {params.subsampling} \
            --include {input.include} {input.specific_include} \
            --probabilistic-sampling \
            --output {output.sequences} \
            --output-metadata {output.metadata} \
            --output-strains {output.strains} \
            --min-length {params.min_length} \
            --output-log {output.log}
        """


rule subsample_nonb1:
    input:
        sequences="results/decent_sequences.fasta",
        metadata="results/decent_metadata.tsv",
        exclude="resources/exclude_accessions.txt",
        specific_exclude="resources/{build_name}/exclude_accessions.txt",
        deduplicate_exclude="results/duplicates.txt",
        specific_include="resources/{build_name}/include_accessions.txt",
        include=lambda w: config[w.build_name]["general_include"],
        index="results/index.tsv",
    output:
        sequences="results/{build_name}/filtered_raw_nonb1.fasta",
        metadata="results/{build_name}/filtered_raw_metadata_nonb1.tsv",
        strains="results/{build_name}/strains_nonb1.txt",
        log="results/{build_name}/filtered_raw_nonb1.log",
    params:
        min_date=lambda w: config[w.build_name]["min_date"],
        min_length=config["min_length"],
        exclude_where=lambda w: config[w.build_name]["exclude_where"]["nonb1"],
        subsampling=lambda w: config[w.build_name]["subsampling"]["nonb1"],
    shell:
        """
        augur filter \
            --sequences {input.sequences} \
            --metadata {input.metadata} \
            --sequence-index {input.index} \
            --metadata-id-columns accession \
            --exclude {input.exclude} {input.specific_exclude} {input.deduplicate_exclude} \
            {params.exclude_where} \
            {params.min_date} \
            {params.subsampling} \
            --include {input.include} {input.specific_include} \
            --probabilistic-sampling \
            --output {output.sequences} \
            --output-metadata {output.metadata} \
            --output-strains {output.strains} \
            --min-length {params.min_length} \
            --output-log {output.log}
        """


rule postsample_exclude:
    input:
        strains=lambda w: [
            f"results/{{build_name}}/strains_{sample}.txt"
            for sample in ["b1", "nonb1"]
        ],
        sequences="results/decent_sequences.fasta",
        metadata="results/decent_metadata.tsv",
        exclude="resources/{build_name}/post_filter_exclude.txt",
        index="results/index.tsv",
    output:
        sequences="results/{build_name}/filtered.fasta",
        metadata="results/{build_name}/metadata.tsv",
        log="results/{build_name}/filtered.log",
    shell:
        """
        augur filter \
            --exclude-all \
            --sequences {input.sequences} \
            --metadata {input.metadata} \
            --sequence-index {input.index} \
            --metadata-id-columns accession \
            --exclude {input.exclude} \
            --include {input.strains} \
            --output {output.sequences} \
            --output-metadata {output.metadata} \
            --output-log {output.log}
        """


rule align:
    input:
        sequences="results/{build_name}/filtered.fasta",
        reference="resources/{build_name}/reference.fasta",
        root="resources/{build_name}/root.fasta",
        annotation=annotation_path,
    output:
        alignment="results/{build_name}/aligned.fasta",
        translations=directory("results/{build_name}/translations"),
    params:
        translation_template=lambda w: f"results/{w.build_name}/translations/{{cds}}.fasta",
        genes=lambda w: ",".join(genes(w)),
    shell:
        """
        cat {input.root} {input.reference} {input.sequences} \
        | seqkit seq -w0 -i \
        | seqkit rmdup -n \
        | nextclade3 run \
            --retry-reverse-complement \
            --input-ref {input.reference} \
            --excess-bandwidth 100 \
            --terminal-bandwidth 300 \
            --allowed-mismatches 8 \
            --window-size 40 \
            --min-seed-cover 0.1 \
            --input-annotation {input.annotation} \
            --gap-alignment-side left \
            --output-fasta /dev/stdout \
            --output-translations {params.translation_template} \
        | seqkit seq -w0 -i > {output.alignment}
        """


rule mask:
    input:
        sequences="results/{build_name}/aligned.fasta",
        mask="resources/{build_name}/mask.bed",
    output:
        "results/{build_name}/masked.fasta",
    shell:
        """
        augur mask \
            --sequences {input.sequences} \
            --mask {input.mask} \
            --output {output}
        """


rule deduplicate_2:
    """
    Remove identical sequences (even if they have differing Ns)
    Keep those sequences with fewer Ns
    Focus for Nextclade is on diversity, not on representativeness
    """
    input:
        sequences="results/{build_name}/masked.fasta",
    output:
        duplicates="results/{build_name}/duplicates.txt",
    shell:
        """
        python3 scripts/deduplicate.py {input.sequences} {output.duplicates}
        """


if TREE_METHOD == "cmaple":

    rule tree:
        input:
            alignment="results/{build_name}/masked.fasta",
        output:
            tree="results/{build_name}/masked.fasta.treefile",
        shell:
            """
            cmaple \
                -aln {input.alignment} \
                -m JC \
                -st DNA \
                --search EXHAUSTIVE \
                --out-mul-tree \
                --make-consistent \
                -nt AUTO \
                --overwrite
            """

else:

    rule tree:
        input:
            alignment="results/{build_name}/masked.fasta",
        output:
            tree="results/{build_name}/masked.fasta.treefile",
        shell:
            """
            augur tree \
                --alignment {input.alignment} \
                --tree-builder-args "--polytomy --ninit 2 -n 2 --epsilon 0.05 -T 4 --redo" \
                --nthreads 4 \
                --output {output.tree}
            """


rule collapse:
    input:
        script="scripts/collapse-zero-branches.py",
        tree=rules.tree.output.tree,
    output:
        tree="results/{build_name}/tree_collapsed.nwk",
    shell:
        """
        python {input.script} \
            --threshold 0.0000001 \
            --verbose \
            --input-tree {input.tree} \
            --output-tree {output.tree}
        """


rule refine:
    input:
        tree="results/{build_name}/tree_collapsed.nwk",
        alignment="results/{build_name}/masked.fasta",
        metadata="results/{build_name}/metadata.tsv",
    output:
        tree="results/{build_name}/tree.nwk",
        node_data="results/{build_name}/branch_lengths.json",
    params:
        root=lambda w: config[w.build_name]["root"],
    shell:
        """
        augur refine \
            --tree {input.tree} \
            --alignment {input.alignment} \
            --metadata {input.metadata} \
            --output-tree {output.tree} \
            --root {params.root} \
            --divergence-unit mutations \
            --keep-polytomies \
            --output-node-data {output.node_data} \
            --seed 42
        """


rule ancestral:
    # "Reconstructing ancestral sequences and mutations"
    input:
        tree="results/{build_name}/tree.nwk",
        alignment="results/{build_name}/masked.fasta",
        annotation=annotation_path,
        genes=lambda w: gene_path(w),
        translations="results/{build_name}/translations",
        reference="resources/{build_name}/reference.fasta",
    output:
        node_data="results/{build_name}/nt_muts.json",
        log="results/{build_name}/ancestral.log",
    params:
        inference="joint",
        translation_template="results/{build_name}/translations/%GENE.fasta",
        genes=lambda w: " ".join(genes(w)),
    shell:
        """
        augur ancestral \
            --tree {input.tree} \
            --annotation {input.annotation} \
            --alignment {input.alignment} \
            --root-sequence {input.reference} \
            --infer-ambiguous \
            --translations {params.translation_template} \
            --genes {params.genes} \
            --output-node-data {output.node_data} \
            --inference joint \
            2>&1 > {output.log}
        """


rule clades:
    # "Adding internal clade labels"
    input:
        tree="results/{build_name}/tree.nwk",
        nuc_muts="results/{build_name}/nt_muts.json",
        clades="resources/{build_name}/clades.tsv",
    output:
        node_data="results/{build_name}/clades_raw.json",
    shell:
        """
        augur clades \
            --tree {input.tree} \
            --mutations {input.nuc_muts} \
            --clades {input.clades} \
            --output-node-data {output.node_data} 2>&1 | tee {log}
        """


rule rename_clades:
    input:
        "results/{build_name}/clades_raw.json",
    output:
        node_data="results/{build_name}/clades.json",
    shell:
        """
        python scripts/clades_renaming.py \
        --input-node-data {input} \
        --output-node-data {output.node_data}
        """


rule colors:
    input:
        ordering="resources/color_ordering.tsv",
        color_schemes="resources/color_schemes.tsv",
        metadata="results/{build_name}/metadata.tsv",
    output:
        colors="results/{build_name}/colors.tsv",
    shell:
        """
        python3 scripts/assign-colors.py \
            --ordering {input.ordering} \
            --color-schemes {input.color_schemes} \
            --output {output.colors} \
            --metadata {input.metadata} 2>&1
        """


rule nice_strain_names:
    input:
        metadata="results/{build_name}/metadata.tsv",
    output:
        metadata="results/{build_name}/metadata_display.tsv",
    shell:
        """
        python3 scripts/make_nice_strain_names.py \
            --metadata {input.metadata} \
            --input-columns geoLocCountry accession date \
            --separator '/' \
            --output-column strain_display \
            --output {output.metadata}
        """


rule patch_auspice_config:
    input:
        auspice_config="resources/auspice_config.json",
        patch_json="resources/{build_name}/auspice_config_patch.json",
    output:
        auspice_config="results/{build_name}/auspice_config.json",
    shell:
        """
        jsonpatch {input.auspice_config} {input.patch_json} > {output.auspice_config}
        """


rule export:
    # "Exporting data files for for auspice"
    input:
        colors="results/{build_name}/colors.tsv",
        tree="results/{build_name}/tree.nwk",
        metadata="results/{build_name}/metadata_display.tsv",
        branch_lengths="results/{build_name}/branch_lengths.json",
        clades="results/{build_name}/clades.json",
        nt_muts="results/{build_name}/nt_muts.json",
        auspice_config="results/{build_name}/auspice_config.json",
    output:
        auspice_json="results/nextclade_mpox_{build_name}.json",
    shell:
        """
        augur export v2 \
            --tree {input.tree} \
            --metadata {input.metadata} \
            --node-data {input.branch_lengths} {input.nt_muts} {input.clades} \
            --colors {input.colors} \
            --auspice-config {input.auspice_config} \
            --include-root-sequence \
            --metadata-id-columns accession \
            --output {output.auspice_json}
        """


rule extra_node_data:
    input:
        metadata="results/{build_name}/metadata.tsv",
        json=rules.export.output.auspice_json,
    output:
        json="auspice/nextclade_mpox_{build_name}_pretty.json",
    run:
        import pandas as pd
        import json

        df = pd.read_csv(input.metadata, sep="\t", keep_default_na=False)

        result = {}
        for index, row in df.iterrows():
            accession = row["accession"]
            accessionVersion = row["accessionVersion"]
            data_use_terms = row["dataUseTerms"]
            data_use_terms_url = row["dataUseTermsUrl"]
            insdc_accession = row["insdcAccessionFull"]
            insdc_accession_url = (
                f"https://www.ncbi.nlm.nih.gov/nuccore/{insdc_accession}"
            )
            url = f"https://pathoplexus.org/seq/{accessionVersion}"
            result[accession] = {
                "url": url,
                "dataUseTerms": {
                    "value": data_use_terms,
                    "url": data_use_terms_url,
                },
            }
            if insdc_accession:
                result[accession]["insdcAccession"] = {
                    "value": insdc_accession,
                    "url": insdc_accession_url,
                }

        with open(input.json) as f:
            data = json.load(f)

        def update_node_data(node):
            name = node["name"]
            if name in result:
                node["node_attrs"] |= result[name]
            if "children" in node:
                for child in node["children"]:
                    update_node_data(child)

        update_node_data(data["tree"])

        with open(output.json, "w") as f:
            json.dump(data, f, indent=2)



rule minify_tree:
    input:
        auspice="auspice/nextclade_mpox_{build_name}_pretty.json",
    output:
        auspice="auspice/nextclade_mpox_{build_name}.json",
    shell:
        """
        gojq -c '.' {input.auspice} > {output.auspice}
        """


rule assemble_dataset:
    input:
        reference="resources/{build_name}/reference.fasta",
        tree="auspice/nextclade_mpox_{build_name}.json",
        pathogen_json="resources/{build_name}/pathogen.json",
        sequences="resources/{build_name}/sequences.fasta",
        annotation=annotation_path,
        readme="resources/{build_name}/README.md",
        changelog="resources/{build_name}/CHANGELOG.md",
    output:
        reference="datasets/{build_name}/reference.fasta",
        tree="datasets/{build_name}/tree.json",
        pathogen_json="datasets/{build_name}/pathogen.json",
        sequences="datasets/{build_name}/sequences.fasta",
        annotation="datasets/{build_name}/genome_annotation.gff3",
        readme="datasets/{build_name}/README.md",
        changelog="datasets/{build_name}/CHANGELOG.md",
    shell:
        """
        cp {input.reference} {output.reference}
        cp {input.tree} {output.tree}
        cp {input.pathogen_json} {output.pathogen_json}
        cp {input.sequences} {output.sequences}
        cp {input.annotation} {output.annotation}
        cp {input.readme} {output.readme}
        cp {input.changelog} {output.changelog}
        """


rule test_dataset:
    input:
        tree="datasets/{build_name}/tree.json",
        pathogen_json="datasets/{build_name}/pathogen.json",
        sequences="datasets/{build_name}/sequences.fasta",
        annotation="datasets/{build_name}/genome_annotation.gff3",
        readme="datasets/{build_name}/README.md",
        changelog="datasets/{build_name}/CHANGELOG.md",
    output:
        outdir=directory("test_output/{build_name}"),
    params:
        dataset_dir="datasets/{build_name}",
    shell:
        """
        nextclade3 run \
            {input.sequences} \
            --input-dataset {params.dataset_dir} \
            --output-all {output.outdir}
        """


rule clean:
    # Removing directories: {params}"
    params:
        "results",
        "auspice",
    shell:
        "rm -rfv {params}"


rule cleanall:
    # Removing directories: {params}"
    params:
        "results",
        "auspice",
        "data",
        "logs",
        "bin",
    shell:
        "rm -rfv {params}"
